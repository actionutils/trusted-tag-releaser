name: Trusted Release Workflow

# This workflow creates a SLSA-compliant release for GitHub repositories
# It's designed as a reusable workflow that can be called from other workflows
# It enforces releases only through labeled PRs (bump:patch, bump:minor, bump:major)
on:
  workflow_call:
    inputs:
      ref:
        description: 'The Git reference (commit SHA, tag, or branch) to use'
        required: false
        default: ${{ github.sha }}
        type: string
      rekor-log-public:
        description: 'Allow repository name to be logged in public Rekor transparency log'
        required: false
        type: boolean
        default: true
      draft:
        description: 'Whether to keep the release as a draft'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Environment for protecting the release flow'
        required: false
        type: string
      release-notes:
        description: 'Custom release notes content (overrides auto-generated notes)'
        required: false
        type: string
      semver-tags-environment:
        description: 'Environment for protecting the major/minor semver tags update (allows using wait timers to delay v1/v2 tag updates)'
        required: false
        type: string
    secrets:
      github-token:
        description: 'GitHub token with appropriate permissions'
        required: true
    outputs:
      tag_name:
        description: 'The tag name created or used for this release'
        value: ${{ jobs.version.outputs.tag_name }}
      version:
        description: 'The version number without "v" prefix'
        value: ${{ jobs.version.outputs.version }}
      release_url:
        description: 'URL of the created GitHub release'
        value: ${{ jobs.release.outputs.release_url }}

permissions: {}

jobs:
  # Check if a release is needed (dry-run)
  release-check:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for GitHub's generate-release-note API (notes are only displayed in job summary, not written to any file)
    outputs:
      skip: ${{ steps.bumpr-dry-run.outputs.skip }}
      next_version: ${{ steps.bumpr-dry-run.outputs.next_version }}
      current_version: ${{ steps.bumpr-dry-run.outputs.current_version }}
      message: ${{ steps.bumpr-dry-run.outputs.message }}
      temp_branch: ${{ steps.create-temp-branch.outputs.temp_branch }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ inputs.ref }}

      # Dry run to check if a version bump is needed
      - id: bumpr-dry-run
        uses: haya14busa/action-bumpr@faf6f474bcb6174125cfc569f0b2e24cbf03d496 # v1.11.4
        with:
          dry_run: true

      # Create temporary branch to prevent GitHub workflow permission error
      #
      # PROBLEM:
      # GitHub incorrectly requires 'workflow: write' permission when pushing tags,
      # even though tags don't actually create or update workflows. The error message:
      # "refusing to allow a GitHub App to create or update workflow .github/workflows/xxx.yaml without workflows permission"
      #
      # This error occurs when:
      # 1. This release workflow is running
      # 2. The main branch gets updated with changes to .github/workflows/
      # 3. We try to push a tag pointing to the older commit
      # 4. GitHub rejects it because no branch HEAD has the same workflow files
      #
      # WHY WE CAN'T JUST ADD 'workflow: write':
      # The default GITHUB_TOKEN in GitHub Actions cannot be granted 'workflow: write'
      # permission for security reasons. Using a PAT with this permission is not
      # recommended as it bypasses important security boundaries.
      #
      # WORKAROUND:
      # Create a temporary 'keep-ref-<version>' branch at the release commit.
      # This ensures at least one branch exists with the exact workflow files
      # from the release commit, satisfying GitHub's check.
      #
      # TIMING:
      # We create this branch early (right after determining the version) because
      # the release-approval job may wait for human approval, during which the
      # main branch could be updated.
      #
      # See: https://github.com/orgs/community/discussions/151442
      - name: Create temporary branch for tag push workaround
        id: create-temp-branch
        if: steps.bumpr-dry-run.outputs.skip != 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.github-token || github.token }}
        run: |
          NEXT_VERSION="${{ steps.bumpr-dry-run.outputs.next_version }}"
          COMMIT_SHA="${{ github.sha }}"
          # Include short commit hash to ensure uniqueness across re-runs/concurrent runs
          SHORT_SHA="${COMMIT_SHA:0:7}"
          TEMP_BRANCH="keep-ref-${NEXT_VERSION}-${SHORT_SHA}"

          echo "Creating temporary branch '${TEMP_BRANCH}' as workaround for GitHub workflow permission issue"
          echo "This prevents 'refusing to allow a GitHub App to create or update workflow' errors"
          echo "when the main branch is updated with different workflow files during release."
          echo "Branch includes commit hash for uniqueness in case of re-runs or concurrent workflows."

          # Create the temporary branch using GitHub API
          # This is cleaner than using git commands and doesn't require git config changes
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${GITHUB_REPOSITORY}/git/refs" \
            -f "ref=refs/heads/${TEMP_BRANCH}" \
            -f "sha=${COMMIT_SHA}"

          echo "‚úÖ Temporary branch '${TEMP_BRANCH}' created successfully at commit ${COMMIT_SHA}"

          # Output the branch name for cleanup job
          echo "temp_branch=${TEMP_BRANCH}" >> "$GITHUB_OUTPUT"

      # Add release information to job summary
      - name: Add release information to job summary
        env:
          GITHUB_TOKEN: ${{ github.token }}
          CUSTOM_RELEASE_NOTES: ${{ inputs.release-notes }}
        run: |
          echo "# Release Check Summary" >> "$GITHUB_STEP_SUMMARY"

          if [[ "${{ steps.bumpr-dry-run.outputs.skip }}" == "true" ]]; then
            {
              echo "## ‚ö†Ô∏è No Release Needed"
              echo "No version bump label was found on the PR. Release will be skipped."
            } >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "## ‚úÖ Release Needed"
              echo "A version bump label was found. The following release will be created:"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"

            # Use action-bumpr outputs with better formatting
            if [[ "${{ steps.bumpr-dry-run.outputs.next_version }}" != "" ]]; then
              CURRENT_VERSION="${{ steps.bumpr-dry-run.outputs.current_version }}"
              NEXT_VERSION="${{ steps.bumpr-dry-run.outputs.next_version }}"
              REPO_URL="https://github.com/${{ github.repository }}"
              COMPARE_URL="$REPO_URL/compare/$CURRENT_VERSION...${{ github.sha }}"

              # Create a more visually appealing format with emojis
              {
                echo "### Release Details"
                echo ""
                echo "üè∑Ô∏è **New Version:** \`$NEXT_VERSION\`"
                echo ""
                echo "üì¶ **Current Version:** \`$CURRENT_VERSION\`"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Add tag message if available
              if [[ "${{ steps.bumpr-dry-run.outputs.message }}" != "" ]]; then
                {
                  echo "üìù **Tag Message:** ${{ steps.bumpr-dry-run.outputs.message }}"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              fi

              # Add GitHub compare link
              {
                echo "üìä **Changes:** [View changes since $CURRENT_VERSION]($COMPARE_URL)"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Generate and add release notes
              {
                echo "### üìù Release Notes Preview"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Check if custom release notes are provided
              if [[ -n "${CUSTOM_RELEASE_NOTES}" ]]; then
                # Use custom release notes
                {
                  echo "**Note:** Using custom release notes provided as input"
                  echo ""
                  echo "${CUSTOM_RELEASE_NOTES}"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              else
                # Generate release notes using GitHub API
                REPO="${{ github.repository }}"

                # Call the API with the parameters (CURRENT_VERSION will be empty string if not set)
                RELEASE_NOTES=$(gh api \
                  --method POST \
                  -H "Accept: application/vnd.github+json" \
                  "/repos/${REPO}/releases/generate-notes" \
                  -f target_commitish="${{ github.sha }}" \
                  -f tag_name="$NEXT_VERSION" \
                  -f previous_tag_name="$CURRENT_VERSION" \
                  --jq '.body')

                # Add the generated release notes to the summary
                {
                  echo "$RELEASE_NOTES"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              fi
            fi
          fi

  # Environment protection job
  # This job intentionally deploys to the environment to satisfy environment
  # protection rules and avoid "Missing successful active release deployment".
  # It also serves as the single approval gate for the release flow.
  release-approval:
    needs: [release-check]
    if: needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    concurrency:
      group: "release-approval"
      cancel-in-progress: true
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Approve release
        run: |
          echo "Release approved in the ${{ inputs.environment }} environment"
          echo "This job exists to satisfy environment deployment requirements."

  # Version management and tag creation job
  version:
    needs: [release-approval, release-check]
    if: needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Enable OIDC
      contents: write # Tag updates
      pull-requests: write # Post comment
    outputs:
      tag_name: ${{ steps.tag.outputs.value }}
      version: ${{ steps.extract-version.outputs.version }}
      current_version: ${{ steps.bumpr.outputs.current_version }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ inputs.ref }}

      # Set up signed tag configuration
      - uses: chainguard-dev/actions/setup-gitsign@de56c2728beb0a0f371bff2ce2ee4b8afee4b5e8

      # EXPERIMENTAL: Use gitsign offline mode
      - run: git config --local gitsign.rekorMode offline

      # Bump version based on PR labels (bump:major,bump:minor,bump:patch)
      - id: bumpr
        uses: haya14busa/action-bumpr@faf6f474bcb6174125cfc569f0b2e24cbf03d496 # v1.11.4

      # Note: Major and minor tags will be updated after release creation

      # Get tag name from bumpr output only
      - id: tag
        run: |
          if [[ "${{ steps.bumpr.outputs.skip }}" == "true" ]]; then
            echo "value=" >> "$GITHUB_OUTPUT"
            echo "No version bump label found, skipping release."
          else
            TAG="${{ steps.bumpr.outputs.next_version }}"
            echo "value=${TAG}" >> "$GITHUB_OUTPUT"
            echo "Next version: ${TAG}"
          fi

      # Extract version number without "v" prefix (v1.2.3 ‚Üí 1.2.3)
      - id: extract-version
        if: steps.tag.outputs.value != ''
        run: |
          TAG=${{ steps.tag.outputs.value }}
          VERSION=${TAG#refs/tags/v}
          VERSION=${VERSION#v}
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Extracted version: ${VERSION}"

  # Prepare information for release attestation
  prepare-slsa:
    needs: [version]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      id-token: write   # Required for attestation
      contents: read    # Required for attestation
      attestations: write # Required for creating attestations
    outputs:
      base64_subjects: ${{ steps.compute-subjects.outputs.base64_subjects }}
    steps:
      # Save commit info for attestation
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      # Compute tag SHA (git rev-parse <tag>) and prepare SLSA generator subjects
      - name: Compute tag SHA and subjects
        id: compute-subjects
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME='${{ needs.version.outputs.tag_name }}'

          # Create a deterministic virtual artifact content directly from GitHub API (includes trailing newline)
          # Equivalent to: git rev-parse <tag>
          FILENAME="${TAG_NAME}.sha"
          gh api "repos/$GITHUB_REPOSITORY/git/refs/tags/$TAG_NAME" --jq '.object.sha' > "$FILENAME"

          # Encode the exact sha256sum output ("<sha256>  <name>") as base64 for the SLSA generator
          BASE64_SUBJECTS=$(sha256sum "$FILENAME" | base64 -w0)

          echo "base64_subjects=$BASE64_SUBJECTS" >> "$GITHUB_OUTPUT"
          echo "Computed tag SHA (rev-parse): $(cat "$FILENAME")"


  # Generate and upload SLSA provenance for the tag SHA artifact BEFORE creating the release content
  slsa-provenance:
    needs: [version, prepare-slsa]
    if: needs.version.outputs.tag_name != ''
    permissions:
      actions: read # To read the workflow path.
      id-token: write # To sign the provenance.
      contents: write # To add assets to a release.
      attestations: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0
    with:
      base64-subjects: ${{ needs.prepare-slsa.outputs.base64_subjects }}
      upload-assets: true
      upload-tag-name: ${{ needs.version.outputs.tag_name }}
      draft-release: true
      provenance-name: release-provenance.intoto.jsonl

  # Create GitHub Release job
  release:
    needs: [version, slsa-provenance]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for release creation
    outputs:
      release_url: ${{ steps.create_release.outputs.release_url }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          ref: ${{ needs.version.outputs.tag_name }}

      # Create or update GitHub Release (draft may be pre-created by SLSA generator)
      - name: Update GitHub Release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
          VERIFICATION_INSTRUCTIONS: |
            <details>
            <summary>üìã Release Verification Instructions</summary>

            Verify this release and its tag provenance using the following examples.

            ### 1) Using [actionutils/trusted-tag-verifier](https://github.com/actionutils/trusted-tag-verifier) (GitHub Actions example)

            ```
            jobs:
              verify:
                runs-on: ubuntu-latest
                steps:
                  - uses: actionutils/trusted-tag-verifier@v0
                    with:
                      verify: '${{ github.repository }}@${{ needs.version.outputs.tag_name }}'
                      fail-on-verification-error: 'true'
                      certificate-oidc-issuer: 'https://token.actions.githubusercontent.com'
                      certificate-identity-regexp: '^https://github.com/actionutils/trusted-tag-releaser'
            ```

            Note that it uses [gitsign](https://github.com/sigstore/gitsign) internally.

            ### 2) Using [gitsign](https://github.com/sigstore/gitsign)

            Clone ${{ github.repository }} and run the following command.

            ```
            gitsign verify-tag \
              --certificate-oidc-issuer='https://token.actions.githubusercontent.com'  \
              --certificate-identity-regexp='^https://github.com/actionutils/trusted-tag-releaser' \
              ${{ needs.version.outputs.tag_name }}
            ```

            ### 3) Using [slsa-verifier](https://github.com/slsa-framework/slsa-verifier)

            ```
            TAG="${{ needs.version.outputs.tag_name }}"
            # Fetch tag object SHA from GitHub API (same as `git rev-parse <tag>`)
            TAG_SHA=$(curl -fsSL "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/${TAG}" | jq -r '.object.sha')

            # Verify SLSA provenance for the tag SHA virtual artifact
            slsa-verifier verify-artifact \
              --source-uri "github.com/${{ github.repository }}" \
              --provenance-path <(curl -fsSL "https://github.com/${{ github.repository }}/releases/download/${TAG}/release-provenance.intoto.jsonl") \
              <(echo "$TAG_SHA")
            ```

            Note: Unlike (1) and (2), it does not verify git tag signature but verifies the uploaded provenance.
            Prefer (1) and (2) in general because there is a time lag between tag creation and release creation.

            </details>
        run: |
          TAG_NAME="${{ needs.version.outputs.tag_name }}"
          REPO="${GITHUB_REPOSITORY}"
          CUSTOM_RELEASE_NOTES="${{ inputs.release-notes }}"

          # Determine release notes
          if [[ -n "${CUSTOM_RELEASE_NOTES}" ]]; then
            # Use custom release notes if provided
            echo "Using custom release notes provided as input..."
            RELEASE_NOTES="${CUSTOM_RELEASE_NOTES}"
          else
            # Generate release notes using GitHub API
            echo "Generating release notes using GitHub API..."
            # Get the current version from bumpr output (will be empty string if not set)
            CURRENT_VERSION="${{ needs.version.outputs.current_version }}"

            # Call the API with the parameters
            RELEASE_NOTES=$(gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              "/repos/${REPO}/releases/generate-notes" \
              -f tag_name="$TAG_NAME" \
              -f previous_tag_name="$CURRENT_VERSION" \
              --jq '.body')
          fi

          # Append verification instructions to the generated release notes
          NOTES_FILE="$(mktemp)"
          printf "%s\n\n%s\n" "$RELEASE_NOTES" "$VERIFICATION_INSTRUCTIONS" > "$NOTES_FILE"

          # Edit existing draft release (created by SLSA generator) with generated notes + verification section
          RELEASE_URL=$(gh release edit "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --notes-file "$NOTES_FILE" \
            --draft=${{ inputs.draft }})

          echo "release_url=$RELEASE_URL" >> "$GITHUB_OUTPUT"
          echo "Release URL: $RELEASE_URL"

  # Update major and minor semver tags after release is created
  update-semver-tags:
    needs: [release, version]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    environment: ${{ inputs.semver-tags-environment }}
    concurrency:
      group: "semver-tags-update"
      cancel-in-progress: true
    permissions:
      id-token: write # Enable OIDC for gitsign
      contents: write # Required to update tags
    outputs:
      major_tag: ${{ steps.update-semver.outputs.major }}
      minor_tag: ${{ steps.update-semver.outputs.minor }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ needs.version.outputs.tag_name }}

      # Set up signed tag configuration
      - uses: chainguard-dev/actions/setup-gitsign@de56c2728beb0a0f371bff2ce2ee4b8afee4b5e8

      # EXPERIMENTAL: Use gitsign offline mode
      - run: git config --local gitsign.rekorMode offline

      # Update corresponding major and minor tags
      - uses: haya14busa/action-update-semver@v1.5.1
        id: update-semver
        with:
          tag: ${{ needs.version.outputs.tag_name }}

  # Clean up temporary branch that was created as a workaround
  #
  # This job deletes the 'keep-ref-<version>' branch that was created to work around
  # GitHub's workflow permission issue. The branch is no longer needed after all tags
  # have been successfully created.
  #
  # The job runs with 'if: always()' to ensure cleanup happens even if other jobs fail,
  # preventing accumulation of temporary branches in the repository.
  cleanup-temp-branch:
    needs: [release-check, update-semver-tags]
    # Always run cleanup, even if previous jobs failed, but only if we started a release
    if: always() && needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to delete branch
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      # Clean up temporary branch created during tag push
      # This branch was created as a workaround for GitHub's workflow permission issue
      # See: https://github.com/orgs/community/discussions/151442
      - name: Delete temporary branch
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          # Get the exact branch name that was created
          TEMP_BRANCH="${{ needs.release-check.outputs.temp_branch }}"

          if [[ -z "${TEMP_BRANCH}" ]]; then
            echo "No temporary branch to clean up (may have been skipped)"
            exit 0
          fi

          echo "Cleaning up temporary branch '${TEMP_BRANCH}' used for workflow permission workaround"

          # Delete the temporary branch (ignore errors if it doesn't exist)
          if gh api "repos/${GITHUB_REPOSITORY}/git/refs/heads/${TEMP_BRANCH}" --silent 2>/dev/null; then
            gh api --method DELETE "repos/${GITHUB_REPOSITORY}/git/refs/heads/${TEMP_BRANCH}" || true
            echo "‚úÖ Temporary branch '${TEMP_BRANCH}' deleted successfully"
          else
            echo "‚ÑπÔ∏è Temporary branch '${TEMP_BRANCH}' not found (may have been already deleted)"
          fi

          echo "Cleanup completed"

  # Verify the release using gh attestation verify
  verify-release:
    needs: [release, slsa-provenance, version, update-semver-tags]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required to read release artifacts
    steps:

      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Install slsa-verifier
        uses: slsa-framework/slsa-verifier/actions/installer@v2.7.1

      - name: Verify SLSA provenance with slsa-verifier
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          set -euo pipefail

          REPO_NAME="${GITHUB_REPOSITORY}"
          TAG="${{ needs.version.outputs.tag_name }}"
          slsa-verifier verify-artifact \
            --source-uri "github.com/$REPO_NAME" \
            --provenance-path <(curl -fsSL "https://github.com/$REPO_NAME/releases/download/${TAG}/release-provenance.intoto.jsonl") \
            <(gh api "repos/$REPO_NAME/git/refs/tags/${TAG}" --jq '.object.sha')

          echo "‚úÖ SLSA provenance verification successful"

      - name: Verify Tag
        id: verify-tag
        uses: actionutils/trusted-tag-verifier@v0
        with:
          verify: '${{ github.repository }}@${{ needs.version.outputs.tag_name }}'
          fail-on-verification-error: 'true'
          certificate-oidc-issuer: 'https://token.actions.githubusercontent.com'
          certificate-identity-regexp: '^https://github.com/actionutils/trusted-tag-releaser'

      - name: Verify Major Tag
        id: verify-major-tag
        if: needs.update-semver-tags.outputs.major_tag != ''
        uses: actionutils/trusted-tag-verifier@v0
        with:
          verify: '${{ github.repository }}@${{ needs.update-semver-tags.outputs.major_tag }}'
          fail-on-verification-error: 'true'
          certificate-oidc-issuer: 'https://token.actions.githubusercontent.com'
          certificate-identity-regexp: '^https://github.com/actionutils/trusted-tag-releaser'

      - name: Verify Minor Tag
        id: verify-minor-tag
        if: needs.update-semver-tags.outputs.minor_tag != ''
        uses: actionutils/trusted-tag-verifier@v0
        with:
          verify: '${{ github.repository }}@${{ needs.update-semver-tags.outputs.minor_tag }}'
          fail-on-verification-error: 'true'
          certificate-oidc-issuer: 'https://token.actions.githubusercontent.com'
          certificate-identity-regexp: '^https://github.com/actionutils/trusted-tag-releaser'
