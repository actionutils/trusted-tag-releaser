name: Trusted Release Workflow

# This workflow creates a SLSA-compliant release for GitHub repositories
# It's designed as a reusable workflow that can be called from other workflows
# It enforces releases only through labeled PRs (bump:patch, bump:minor, bump:major)
on:
  workflow_call:
    inputs:
      ref:
        description: 'The Git reference (commit SHA, tag, or branch) to use'
        required: false
        default: ${{ github.sha }}
        type: string
      rekor-log-public:
        description: 'Allow repository name to be logged in public Rekor transparency log'
        required: false
        type: boolean
        default: true
      draft:
        description: 'Whether to keep the release as a draft'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Environment for protecting the release flow'
        required: false
        type: string
        # Default to "release" so callers don't have to pass it.
        # This also avoids "Missing successful active release deployment" errors
        # by ensuring a deployment target exists by default.
        default: 'release'
    secrets:
      github-token:
        description: 'GitHub token with appropriate permissions'
        required: true
    outputs:
      tag_name:
        description: 'The tag name created or used for this release'
        value: ${{ jobs.version.outputs.tag_name }}
      version:
        description: 'The version number without "v" prefix'
        value: ${{ jobs.version.outputs.version }}
      release_url:
        description: 'URL of the created GitHub release'
        value: ${{ jobs.release.outputs.release_url }}

permissions:
  contents: read

jobs:
  # Check if a release is needed (dry-run)
  release-check:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for GitHub's generate-release-note API (notes are only displayed in job summary, not written to any file)
    outputs:
      skip: ${{ steps.bumpr-dry-run.outputs.skip }}
      next_version: ${{ steps.bumpr-dry-run.outputs.next_version }}
      current_version: ${{ steps.bumpr-dry-run.outputs.current_version }}
      message: ${{ steps.bumpr-dry-run.outputs.message }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ inputs.ref }}

      # Dry run to check if a version bump is needed
      - id: bumpr-dry-run
        uses: haya14busa/action-bumpr@faf6f474bcb6174125cfc569f0b2e24cbf03d496 # v1.11.4
        with:
          dry_run: true

      # Add release information to job summary
      - name: Add release information to job summary
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          echo "# Release Check Summary" >> "$GITHUB_STEP_SUMMARY"

          if [[ "${{ steps.bumpr-dry-run.outputs.skip }}" == "true" ]]; then
            {
              echo "## ⚠️ No Release Needed"
              echo "No version bump label was found on the PR. Release will be skipped."
            } >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "## ✅ Release Needed"
              echo "A version bump label was found. The following release will be created:"
              echo ""
            } >> "$GITHUB_STEP_SUMMARY"

            # Use action-bumpr outputs with better formatting
            if [[ "${{ steps.bumpr-dry-run.outputs.next_version }}" != "" ]]; then
              CURRENT_VERSION="${{ steps.bumpr-dry-run.outputs.current_version }}"
              NEXT_VERSION="${{ steps.bumpr-dry-run.outputs.next_version }}"
              REPO_URL="https://github.com/${{ github.repository }}"
              COMPARE_URL="$REPO_URL/compare/$CURRENT_VERSION...${{ github.sha }}"

              # Create a more visually appealing format with emojis
              {
                echo "### Release Details"
                echo ""
                echo "🏷️ **New Version:** \`$NEXT_VERSION\`"
                echo ""
                echo "📦 **Current Version:** \`$CURRENT_VERSION\`"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Add tag message if available
              if [[ "${{ steps.bumpr-dry-run.outputs.message }}" != "" ]]; then
                {
                  echo "📝 **Tag Message:** ${{ steps.bumpr-dry-run.outputs.message }}"
                  echo ""
                } >> "$GITHUB_STEP_SUMMARY"
              fi

              # Add GitHub compare link
              {
                echo "📊 **Changes:** [View changes since $CURRENT_VERSION]($COMPARE_URL)"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Generate and add release notes using GitHub API
              {
                echo "### 📝 Release Notes Preview"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"

              # Call GitHub API to generate release notes
              REPO="${{ github.repository }}"

              # Call the API with the parameters (CURRENT_VERSION will be empty string if not set)
              RELEASE_NOTES=$(gh api \
                --method POST \
                -H "Accept: application/vnd.github+json" \
                "/repos/${REPO}/releases/generate-notes" \
                -f target_commitish="${{ github.sha }}" \
                -f tag_name="$NEXT_VERSION" \
                -f previous_tag_name="$CURRENT_VERSION" \
                --jq '.body')

              # Add the generated release notes to the summary
              {
                echo "$RELEASE_NOTES"
                echo ""
              } >> "$GITHUB_STEP_SUMMARY"
            fi
          fi

  # Environment protection job
  # This job intentionally deploys to the environment to satisfy environment
  # protection rules and avoid "Missing successful active release deployment".
  # It also serves as the single approval gate for the release flow.
  release-approval:
    needs: [release-check]
    if: needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    concurrency:
      group: "release-approval"
      cancel-in-progress: true
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Approve release
        run: |
          echo "Release approved in the '${{ inputs.environment }}' environment"
          echo "This job exists to satisfy environment deployment requirements."

  # Version management and tag creation job
  version:
    needs: [release-approval, release-check]
    if: needs.release-check.outputs.skip != 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Enable OIDC
      contents: write # Tag updates
      pull-requests: write # Post comment
    outputs:
      tag_name: ${{ steps.tag.outputs.value }}
      version: ${{ steps.extract-version.outputs.version }}
      current_version: ${{ steps.bumpr.outputs.current_version }}
      major_tag: ${{ steps.update-semver.outputs.major }}
      minor_tag: ${{ steps.update-semver.outputs.minor }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          ref: ${{ inputs.ref }}

      # Set up signed tag configuration
      - uses: chainguard-dev/actions/setup-gitsign@f632aec66edeebe245ad686a33a0c0a2160cac31

      # EXPERIMENTAL: Use gitsign offline mode
      - run: git config --local gitsign.rekorMode offline

      # Bump version based on PR labels (bump:major,bump:minor,bump:patch)
      - id: bumpr
        uses: haya14busa/action-bumpr@faf6f474bcb6174125cfc569f0b2e24cbf03d496 # v1.11.4

      # Update corresponding major and minor tags
      - uses: haya14busa/action-update-semver@v1.5.0
        id: update-semver
        if: steps.bumpr.outputs.skip != 'true'
        with:
          tag: ${{ steps.bumpr.outputs.next_version }}

      # Get tag name from bumpr output only
      - id: tag
        run: |
          if [[ "${{ steps.bumpr.outputs.skip }}" == "true" ]]; then
            echo "value=" >> "$GITHUB_OUTPUT"
            echo "No version bump label found, skipping release."
          else
            TAG="${{ steps.bumpr.outputs.next_version }}"
            echo "value=${TAG}" >> "$GITHUB_OUTPUT"
            echo "Next version: ${TAG}"
          fi

      # Extract version number without "v" prefix (v1.2.3 → 1.2.3)
      - id: extract-version
        if: steps.tag.outputs.value != ''
        run: |
          TAG=${{ steps.tag.outputs.value }}
          VERSION=${TAG#refs/tags/v}
          VERSION=${VERSION#v}
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Extracted version: ${VERSION}"

  # Prepare information for release attestation
  prepare-slsa:
    needs: [version]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      id-token: write   # Required for attestation
      contents: read    # Required for attestation
      attestations: write # Required for creating attestations
    outputs:
      commit_sha: ${{ steps.save-info.outputs.commit_sha }}
      tag_name: ${{ steps.save-info.outputs.tag_name }}
      major_tag: ${{ steps.save-info.outputs.major_tag }}
      minor_tag: ${{ steps.save-info.outputs.minor_tag }}
    steps:
      # Save commit info for attestation
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Save commit info
        id: save-info
        run: |
          COMMIT_SHA="${{ github.sha }}"
          TAG="${{ needs.version.outputs.tag_name }}"
          TAG_NAME="${TAG#refs/tags/}"
          MAJOR_TAG="${{ needs.version.outputs.major_tag }}"
          MINOR_TAG="${{ needs.version.outputs.minor_tag }}"

          {
            echo "commit_sha=$COMMIT_SHA"
            echo "tag_name=$TAG_NAME"
            echo "major_tag=$MAJOR_TAG"
            echo "minor_tag=$MINOR_TAG"
          } >> "$GITHUB_OUTPUT"
          echo "Using commit: $COMMIT_SHA with tag: $TAG_NAME for provenance"

      # Generate release-identity.intoto.jsonl file for release verification
      # Note: We intentionally do not include source code archives (zip/tar.gz) in the release attestation
      # because GitHub does not guarantee their stability over time:
      # - https://docs.github.com/en/repositories/working-with-files/using-files/downloading-source-code-archives#stability-of-source-code-archives
      # - https://github.blog/open-source/git/update-on-the-future-stability-of-source-code-archives-and-hashes/
      # Instead, we include the commit SHA in release-identity.intoto.jsonl and verify that it matches the SHA that the tag points to.
      - name: Generate release identity file
        id: generate-metadata
        run: |
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          CREATED_AT=$(date +%s)  # Unix timestamp (seconds since epoch)

          # Create release-identity.intoto.jsonl file using in-toto Statement format
          cat > release-identity.intoto.jsonl << EOF
          {
            "_type": "https://in-toto.io/Statement/v0.1",
            "predicateType": "https://github.com/actionutils/trusted-tag-releaser/tree/main/in-toto/release-identity/v1",
            "subject": [
              {
                "name": "$REPO_NAME",
                "digest": {
                  "git": "${{ github.sha }}"
                }
              }
            ],
            "predicate": {
              "version": "${{ needs.version.outputs.tag_name }}",
              "created_at": $CREATED_AT,
              "git": {
                "tag": "${{ needs.version.outputs.tag_name }}",
                "repository": "https://github.com/$GITHUB_REPOSITORY"
              }
            }
          }
          EOF

          echo "Generated release-identity.intoto.jsonl"



      # Upload release-identity.intoto.jsonl as an artifact to share between jobs
      - name: Upload release identity artifact
        id: upload-identity
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: release-identity-intoto
          path: release-identity.intoto.jsonl
          retention-days: 1

      - uses: actions/attest-build-provenance@977bb373ede98d70efdf65b84cb5f73e068dcc2a # v3.0.0
        with:
          subject-path: release-identity.intoto.jsonl


  # Create GitHub Release job
  release:
    needs: [version, prepare-slsa]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for release creation
    outputs:
      release_url: ${{ steps.create_release.outputs.release_url }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0
          ref: ${{ needs.version.outputs.tag_name }}

      # Download the artifacts from previous jobs

      - name: Download release-identity.intoto.jsonl
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          name: release-identity-intoto

      # Create GitHub Release
      - name: Create GitHub Release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME="${{ needs.prepare-slsa.outputs.tag_name }}"
          REPO="${GITHUB_REPOSITORY}"

          # Generate release notes using GitHub API
          echo "Generating release notes using GitHub API..."
          # Get the current version from bumpr output (will be empty string if not set)
          CURRENT_VERSION="${{ needs.version.outputs.current_version }}"

          # Call the API with the parameters
          RELEASE_NOTES=$(gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            "/repos/${REPO}/releases/generate-notes" \
            -f tag_name="$TAG_NAME" \
            -f previous_tag_name="$CURRENT_VERSION" \
            --jq '.body')

          # Create release with generated notes
          RELEASE_URL=$(gh release create "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --draft=${{ inputs.draft }} \
            --notes "$RELEASE_NOTES" \
            release-identity.intoto.jsonl)

          echo "release_url=$RELEASE_URL" >> "$GITHUB_OUTPUT"
          echo "Release URL: $RELEASE_URL"

  # Verify the release using gh attestation verify
  verify-release:
    needs: [release, prepare-slsa]
    if: needs.prepare-slsa.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required to read release artifacts
    steps:

      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Create temporary directory
        id: tempdir
        run: |
          # Create temporary directory
          TEMP_DIR=$(mktemp -d)
          echo "dir=$TEMP_DIR" >> "$GITHUB_OUTPUT"
          echo "Created temporary directory: $TEMP_DIR"

      - name: Download files for verification
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME="${{ needs.prepare-slsa.outputs.tag_name }}"
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"

          # Download release-identity.intoto.jsonl
          gh release download "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --pattern "release-identity.intoto.jsonl" --dir "$TEMP_DIR"

          echo "Downloaded files to: $TEMP_DIR"
          ls -la "$TEMP_DIR"

      # Verify commit SHA
      # Since we don't include source code archives in the release attestation due to their instability,
      # we instead verify that the commit SHA in release-identity.intoto.jsonl matches the SHA that the tag points to.
      # This provides a more reliable verification mechanism that isn't affected by GitHub's archive generation process.
      - name: Verify commit SHA
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME="${{ needs.prepare-slsa.outputs.tag_name }}"
          REPO_NAME="${GITHUB_REPOSITORY}"
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"

          # Use the identity file
          IDENTITY_FILE="$TEMP_DIR/release-identity.intoto.jsonl"

          if [ ! -f "$IDENTITY_FILE" ]; then
            echo "Error: No release-identity.intoto.jsonl file found"
            exit 1
          fi

          # Verify that the commit SHA in release-identity.intoto.jsonl matches the SHA that the tag points to
          echo "Verifying commit SHA in release-identity.intoto.jsonl..."

          # Get the commit SHA from release-identity.intoto.jsonl
          IDENTITY_COMMIT_SHA=$(jq -r '.subject[0].digest.git' "$IDENTITY_FILE")

          # Get the commit SHA that the tag points to using GitHub API
          # First, get the tag SHA
          TAG_SHA=$(gh api "repos/$REPO_NAME/git/refs/tags/$TAG_NAME" --jq '.object.sha')
          echo "Tag SHA: $TAG_SHA"

          # Then, get the commit SHA that the tag points to
          TAG_COMMIT_SHA=$(gh api "repos/$REPO_NAME/git/tags/$TAG_SHA" --jq '.object.sha')

          echo "Commit SHA in release-identity.intoto.jsonl: $IDENTITY_COMMIT_SHA"
          echo "Commit SHA that tag $TAG_NAME points to: $TAG_COMMIT_SHA"

          # Verify that the commit SHAs match
          if [ "$IDENTITY_COMMIT_SHA" != "$TAG_COMMIT_SHA" ]; then
            echo "❌ Commit SHA verification failed! The commit SHA in release-identity.intoto.jsonl does not match the SHA that the tag points to."
            exit 1
          fi

          echo "✅ Commit SHA verification successful!"


      - name: Verify build provenance attestation
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
          GH_FORCE_TTY: 1
        run: |
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"
          IDENTITY_FILE="$TEMP_DIR/release-identity.intoto.jsonl"
          echo "Verifying build provenance attestation for release-identity.intoto.jsonl"

          gh attestation verify "$IDENTITY_FILE" --repo "$GITHUB_REPOSITORY" --signer-repo=actionutils/trusted-tag-releaser

          echo "✅ Build provenance attestation verification successful!"

      - name: Verify Tag
        id: verify-tag
        uses: actionutils/trusted-tag-verifier@v0
        with:
          verify: '${{ github.repository }}@${{ needs.prepare-slsa.outputs.tag_name }}'
          fail-on-verification-error: 'true'
          certificate-oidc-issuer: 'https://token.actions.githubusercontent.com'
          certificate-identity-regexp: '^https://github.com/actionutils/trusted-tag-releaser'

      - name: Verify Major Tag
        id: verify-major-tag
        if: needs.prepare-slsa.outputs.major_tag != ''
        uses: actionutils/trusted-tag-verifier@v0
        with:
          verify: '${{ github.repository }}@${{ needs.prepare-slsa.outputs.major_tag }}'
          fail-on-verification-error: 'true'
          certificate-oidc-issuer: 'https://token.actions.githubusercontent.com'
          certificate-identity-regexp: '^https://github.com/actionutils/trusted-tag-releaser'

      - name: Verify Minor Tag
        id: verify-minor-tag
        if: needs.prepare-slsa.outputs.minor_tag != ''
        uses: actionutils/trusted-tag-verifier@v0
        with:
          verify: '${{ github.repository }}@${{ needs.prepare-slsa.outputs.minor_tag }}'
          fail-on-verification-error: 'true'
          certificate-oidc-issuer: 'https://token.actions.githubusercontent.com'
          certificate-identity-regexp: '^https://github.com/actionutils/trusted-tag-releaser'

      - name: Cleanup
        if: always()
        run: |
          # Clean up temporary directory
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"
          if [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
            echo "Temporary directory cleaned up: $TEMP_DIR"
          fi
